use crate::lex::{TokenType, Op, Key};
use crate::ast::{Ast, self};
use crate::Type;
use crate::types;

grammar;

extern {
    type Location = usize;
    type Error = ();

    enum TokenType {
        "(" => TokenType::LeftBrace('('),
        ")" => TokenType::RightBrace(')'),
        "{" => TokenType::LeftBrace('{'),
        "}" => TokenType::RightBrace('}'),

        "fun" => TokenType::Key(Key::Fun),
        IntegerType => TokenType::IntType(<Type>),
        "struct" => TokenType::Key(Key::Struct),
        "union"  => TokenType::Key(Key::Union),
        "ptr" => TokenType::Key(Key::Ptr),
        "const" => TokenType::Key(Key::Const),
        "ext"   => TokenType::Key(Key::Ext),
        "ret"   => TokenType::Key(Key::Ret),
        "if"    => TokenType::Key(Key::If),
        "else"  => TokenType::Key(Key::Else),
        "while" => TokenType::Key(Key::While),
        "var"   => TokenType::Key(Key::Var),
        "void"  => TokenType::Key(Key::Void),

        ";" => TokenType::Semicolon,
        "." => TokenType::Dot,
        Ident => TokenType::Ident(<String>),
        StrLiteral => TokenType::StrLiteral(<String>),
        NumLiteral => TokenType::NumLiteral(<String>),
        Op => TokenType::Op(<Op>),
        "," => TokenType::Comma,
    }
}

//A program is made up of declarations
pub Program: Vec<Ast> = {
    <ds:Decl*> => ds,
}

Decl: Ast = {
    <s:FunProto> ";" => Ast::FunProto(s),
    <d:FunDef> => d,
    <s:StructDef> => Ast::StructDef(s),
    <u:UnionDef> => Ast::UnionDef(u),
}

FunProto: ast::FunProto = {
    "fun" <attrs:Attributes> <name:Ident> "(" <args:CommaList<(Typename Ident?)>> ")" <ret:Typename> => ast::FunProto {
        name,
        ret,
        attrs,
        args,
    }
};

FunDef: Ast = <proto: FunProto> <body:Body> => Ast::FunDef(proto, body);

UnionDef: types::Container = {
    "union" <name:Ident> "{" <fields:CommaList<(Typename Ident)>> "}" => types::Container {
        name,
        fields: fields.iter().map(|(ty, name)| (name.clone(), ty.clone())).collect()
    },
}

StructDef: types::Container = {
    "struct" <name:Ident> "{" <fields:CommaList<(Typename Ident)>> "}" => types::Container {
        name,
        fields: fields.iter().map(|(ty, name)| (name.clone(), ty.clone())).collect()
    },
};

//A body of expressions
Body: Vec<Ast> = "{" <exprs:FullExpr*> "}" => exprs;

//A semicolon terminated expression
FullExpr: Ast = <e:Expr> ";" => e;

Expr: Ast = {
    PrimaryExpr,
    BinExpr,
    "(" <e:Expr> ")" => e,
    "ret" <e:Expr> => Ast::Ret(Box::new(e)),
    ItemAccess,
    AssocFunAccess,
};

PrimaryExpr: Ast = {
    //A constant number literal 
    <n:NumLiteral> <ty:IntegerType?> => Ast::NumLiteral(ty.unwrap_or(Type::Integer{width: 32, signed: true}), n),
    VarDecl,
    VarAccess,
    UnaryExpr,
    <f:FunCall> => Ast::FunCall(f.0, f.1),
    <s:StrLiteral> => Ast::StrLiteral(s),
    IfExpr,
    WhileExpr,
};

ItemAccess: Ast = {
    <e:PrimaryExpr> "." <n:Ident> => Ast::MemberAccess(Box::new(e), n),
};

AssocFunAccess: Ast = {
    <e:PrimaryExpr> "." <f:FunCall> => Ast::AssocFunAccess(Box::new(e), f.0, f.1),
};

IfExpr: Ast = {
    "if" <cond:Expr> <on_true:Body> <on_else:("else" <Body>)?> => Ast::If {
        cond: Box::new(cond),
        true_block: on_true,
        else_block: on_else,
    }
};

WhileExpr: Ast = {
    "while" <cond:Expr> <block:Body> => Ast::While {
        cond: Box::new(cond),
        block,
    }
};

//A function call with argument expressions
FunCall: (String, Vec<Ast>) = {
    <name:Ident> "(" <args:CommaList<Expr>> ")" => (name, args)
};

//A unary operator being applied to an expression
UnaryExpr: Ast = <o:Op> <e:PrimaryExpr> => Ast::Unary(o, Box::new(e));

//Variable value access
VarAccess: Ast = <i:Ident> => Ast::VarAccess(i);

//Variable declaration
VarDecl: Ast = {
    "var" <ty:Typename> <attrs:Attributes> <name:Ident> => Ast::VarDecl{ty, name, attrs},
};

BinExpr: Ast = {
    <lhs:PrimaryExpr> <o:Op> <rhs:Expr> => Ast::Bin(Box::new(lhs), o, Box::new(rhs))
};

CommaList<T>: Vec<T> = {
    <mut first:(<T> ",")*> <last:T?> => match last {
        Some(e) => {
            first.push(e);
            first
        },
        None => first,
    }
};

Attributes: ast::Attributes = {
    <attrs:Attribute*> => attrs.iter().fold(ast::Attributes::empty(), |acc, v| acc | *v),
};

Attribute: ast::Attributes = {
    "const" => ast::Attributes::CONST,
    "ext"   => ast::Attributes::EXT,
};

Typename: Type = {
    <ity:IntegerType> => ity,
    <t:Typename> "ptr" => t.ptr_type(),
    "struct" <n:Ident> => Type::UnknownStruct(n),
    "union"  <n:Ident> => Type::UnknownUnion(n),
    "void" => Type::Void,
    <t:Ident> => Type::Unknown(t),
};


