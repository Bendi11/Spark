ns std::str {

//The Str struct holds a string with length and capacity
struct Str {
    u8 ptr _raw,
    u32 len,
    u32 _cap
}

//Allocate a new string data on the heap with default capacity and 0 len
fun str_new() Str {
    ret struct Str {
        _raw = std::alloc::malloc(10u64),
        len = 0u32,
        _cap = 10u32,
    };
}

//Get the string's contents as a NULL-terminated C-style string
fun str_raw(Str ptr str) u8 ptr {
    if (*str)._cap == (*str).len {
        extend_cap(str, 1u32);
    };

    ((*std::alloc::ptr_off_add((*str)._raw, ({u64}(*str).len)))) = 0u8;
    ret (*str)._raw;
}

//Use an existing NULL-terminated string to fill a string's contents
fun str_from(u8 ptr str) Str {
    let u32 len = null::strlen(str);
    let Str string = struct Str {
        _raw = std::alloc::malloc({u64}len),
        len = len,
        _cap = len,
    };

    let u32 pos = 0;
    while pos < len {
        let u8 ptr off = std::alloc::ptr_off_add(string._raw, {u64}pos);
        (*off) = *std::alloc::ptr_off_add(str, {u64}pos);
        pos = pos + 1;
    };
    ret string;
}

//Push a character to the string
fun str_push(Str ptr str, u8 char) void {
    //Extend string storage if needed
    if str->_cap == (*str).len {
        extend_cap(str, 10u32);
    };

    let u8 ptr next = std::alloc::ptr_off_add( (*str)._raw, ({u64}(*str).len));
    (*next) = char;
    (*str).len = (*str).len + 1u32;
    ret;
}

//Extend the internal capacity of this string
fun extend_cap(Str ptr str, u32 count) void {
    (*str)._cap = (*str)._cap + count;
    (*str)._raw = std::alloc::realloc((*str)._raw, {u64}( (*str)._cap));
    std::io::puts("Reallocated string data!\n");
    ret;
}

//Write a string's contents to stdout
fun write_to_stdout(Str ptr str) void {
    std::io::write_stdout((*str)._raw, {u64}(*str).len);
    ret;
}

}

