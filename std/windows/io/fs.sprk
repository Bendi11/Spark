ns std::io::fs {
use std::win::types
use std::consts

//The File struct holds a HANDLE on windows that is used to access the file in the windows
//API
struct File {
    types::Handle handle
}

//The `Opts` struct holds platform-specific flags for the creation and opening
//of files
struct Opts {
    types::Dword dwDesiredAccess,
    types::Dword dwFlagsAndAttributes,
    types::Dword dwCreationDisposition
}

//Open or create the specified file, depending on the given open options
//returns NULL on failure, and an allocated File struct on success.
//Currently corresponds to the CreateFileA function on windows
fun open(u8 ptr filename, Opts openopts) File ptr {
    let types::Handle handle = _internal::CreateFileA(
        filename,
        openopts.dwDesiredAccess,
        0u32,
        {_internal::SecurityAttributes ptr}0,
        openopts.dwCreationDisposition,
        openopts.dwFlagsAndAttributes,
        {types::Handle}0
    );
    if handle == types::INVALID_HANDLE_VALUE {
        ret {File ptr}consts::NULL;
    };
    let File ptr file = {File ptr}std::alloc::malloc(64usize);
    file->handle = handle;
    ret file;
}

//Read the specified amount of bytes from the file into a memory buffer, returning the 
//amount of bytes read or a negative error code
fun read(File ptr file, u8 ptr buf, usize len) isize {
    let types::Dword read_bytes;
    let types::Bool success = _internal::ReadFile(file->handle, buf, {types::Dword}len, (&read_bytes), {_internal::OverLapped ptr}0u64);
    if success > 0u8 {
        ret {isize}read_bytes;
    } else {
        ret -1isize;
    };
    ret 0isize;
}

//Write the specified amount of bytes from a memory buffer, returning the amount of bytes written or
//a negative error 
fun write(File ptr file, u8 ptr buf, usize len) isize {
    let types::Dword written;
    let types::Bool success = _internal::WriteFile(file->handle, buf, {types::Dword}len, &written, {_internal::OverLapped ptr}0);
    if success > 0 {
        ret {isize}written;
    } else {
        ret -1isize;
    };
    ret 0isize;
}

//Close the specified file
fun close(File ptr file) void {
    std::win::_internal::CloseHandle(file->handle);
    ret;
}

//Return the default options for file creation / opening
fun opts_default() Opts {
    ret struct Opts {
        dwDesiredAccess = 2147483648u32 | 1073741824u32,
        dwFlagsAndAttributes = 0u32,
        dwCreationDisposition = 1u32
    };
}

fun add_opt_flag(Opts ptr opts, opt_flag flag) void {
    switch flag {
        //CREATE_NEW
        0u8 -> {
            opts->dwCreationDisposition = 1u32;
        }
        //ALWAYS_CREATE
        1u8 -> {
            opts->dwCreationDisposition = 2u32;
        },
        //READ
        2u8 -> {
            opts->dwDesiredAccess = opts->dwDesiredAccess | 2147483648u32;
        }
        //WRITE
        3u8 -> {
            opts->dwDesiredAccess = opts->dwDesiredAccess | 1073741824u32;
        }
    };
    ret;
}


ns _internal {

    use std::win::types

    struct OverLapped {
        u32 ptr Internal,
        u32 ptr InternalHigh,
        OverLapped_DUMMYUNIONNAME DUMMYUNIONNAME,
        types::Handle hEvent
    }
    union OverLapped_DUMMYUNIONNAME {
        OverLapped_DUMMYSTRUCTNAME DUMMYSTRUCTNAME,
        u8 ptr Pointer
    }
    struct OverLapped_DUMMYSTRUCTNAME {
        u32 Offset,
        u32 OffsetHigh
    }

    struct SecurityAttributes {
        i32 nLength,
        u8 ptr lpSecurityDescriptor,
        types::Bool bInheritHandle
    }

    fun ext WriteFile(types::Handle hFile, u8 ptr lpBuffer, u32 nNumberOfBytesToWrite, u32 ptr lpNumberOfBytesWritten, OverLapped ptr lpOverlapped) types::Bool
    fun ext CreateFileA(u8 ptr lpFileName, 
        types::Dword dwDesiredAccess, 
        types::Dword dwShareMode, 
        SecurityAttributes ptr lpSecurityAttributes, 
        types::Dword dwCreationDisposition, 
        types::Dword dwFlagsAndAttributes, 
        types::Handle hTemplateFile
    ) types::Handle
    fun ext ReadFile(types::Handle hFile, u8 ptr lpBuffer, types::Dword nNumberOfBytesToRead, types::Dword ptr lpNumberOfBytesRead, OverLapped ptr lpOverlapped) types::Bool
}

}
