imp mod:spec
imp std:libc:puts
imp std:libc:cstr

glob a = 3
glob<T> b = "test"
glob<T = i32> b = "testing"

glob<T> [{
    fun(T) -> i32 a
}] io

glob<T = i32> io = #{
    a = $fun(i32) -> i32 puts
}

type<T> test = {
    T first,
    i32 second
}

type none = ()
type<T> opt = T | none
type<T = u64> opt = none
type<T> identity = fun(T) -> T

type<T> test_with_i32 = test:<T> | opt:<T>


fun<T = i32> testing() -> *i32 {
    puts($cstr "Hello from i32 function")
    return $*i32 0u64
}

fun<T = u64> testing() -> *u64 {
    puts($cstr "Hello from generic function")
    return $*u64 0u64
}

fun<T: io:<T> > testing() -> *T {
    return $*T io:<T>.a
}

fun<T> unwrap(opt:<T> opt) -> T {
    return match opt {
        T -> phi $T opt,
        none -> phi $T opt
    }
}

fun ext main(i32 argc, **u8 argv) -> i32 {
    let special = $spec:<i32> 100u64
    let d = $identity:<i32> testing:<i32>
    let c = d(100)
    let a = #test:<i32> {
        first = 31,
        second = 1
    }

    let optional = $opt:<i32> 100
    let unwrapped = $i32 optional
    let unwrapped = unwrap:<i32>(optional)
    let test = b:<i32>
    testing:<i32>()
    testing:<u64>()
    testing:<i32>()
    return 0
}
