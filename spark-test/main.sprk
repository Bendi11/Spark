imp mod:spec

type test<T> = {
    T first,
    i32 second
}

type none = ()
type opt<T> = T | none
type opt:<u64> = none
type identity<T> = fun(T) -> T

fun ext puts(*u8)

type test_with_i32<T> = test:<T> | opt:<T>

fun testing<T>() -> *T

fun testing:<i32>() -> *i32 {
    puts("Hello from i32 function")
    return $*i32 0u64
}

fun testing:<u64>() -> *u64 {
    puts("Hello from generic function")
    return $*u64 0u64
}



fun unwrap<T>(opt:<T> opt) -> T {
    return match opt {
        T -> phi $T opt,
        none -> phi $T opt
    }
}

fun ext main(i32 argc, **u8 argv) -> i32 {
    let special = $spec:<i32> 100u64
    let d = $identity:<i32> testing:<i32>
    let c = d(100)
    let a = #test:<i32> {
        first = 31,
        second = 1
    }

    let optional = $opt:<i32> 100
    let unwrapped = $i32 optional
    let unwrapped = unwrap:<i32>(optional)

    testing:<i32>()
    testing:<u64>()
    testing:<i32>()
    return 0
}
